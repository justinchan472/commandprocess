library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.NUMERIC_STD.ALL;

entity cmdProc is
  port (
    clk         : in  STD_LOGIC;
    reset       : in  STD_LOGIC;     -- active low reset 
    -- UART Rx
    done        : out  STD_LOGIC;
    valid       : in  STD_LOGIC;
    oe          : in  STD_LOGIC;
    fe          : in  STD_LOGIC;
    data_in     : in  STD_LOGIC_VECTOR (7 downto 0);
    -- UART Tx
    data_out    : out STD_LOGIC_VECTOR (7 downto 0);
    txNow       : out STD_LOGIC;
    txDone      : in STD_LOGIC;
    -- Data processing
    start       : out STD_LOGIC;
    numWords    : out STD_LOGIC_VECTOR (11 downto 0);
    dataReady   : in  STD_LOGIC;
    byte        : in STD_LOGIC_VECTOR (7 downto 0);
    maxIndex    : in STD_LOGIC_VECTOR (11 downto 0);
    dataResults : in STD_LOGIC_VECTOR (55 downto 0);
    seqDone     : in STD_LOGIC
  );
end cmdProc;

architecture rtl of cmdProc is      -- rtl = register-transfer level 

-- define state type and signal state
    type state_type is (
        IDLE, -- waiting for start of command
        RX_CAPTURE, -- capture incoming command byte
        LOAD, -- capture or latch command input into internal register 
        START_PROC, -- assert 'start' to processing block
        PROC_WAIT, --wait for seqDone process to complete
        SEND_STATUS, -- assert txNow and put status byte on data_out
        WAIT_TX_DONE, --wait for an external event or condition 
        DONE_STATE, -- finalise command processing and present results to the outside world
        ERROR_STATE ); -- an error/interuption occured while processing the command 
        

    signal state : state_type := IDLE;
    signal next_state: P_state_type :=IDLE;

-- internal registers to hold captured command and parameters
    signal cmg_reg   : std_logic_vector(7 downto 0) := (others => '0');
    signal numWords_reg : std_logic_vector(11 downto 0) := (others => '0');
    signal dataout_reg : std_logic_vector(7 downto 0) := (others => '0');

begin      
-- two state is require in this process
-- this is the first state
-- synchronous state register + registered update 
-- reset is active low: reset = 0 --> reset to intial values instantly 

    state_reg : process(clk,reset)                                                      
    begin                                                             
        if reset = '0' then
          state       <= IDLE;
          cmd_reg     <= (others =>'0');
          numWords_reg     <= (others =>'0');
          data_out_reg     <= (others =>'0');
elseif rusing_edge(clk) then 
          state <= next_state;

-- register 
